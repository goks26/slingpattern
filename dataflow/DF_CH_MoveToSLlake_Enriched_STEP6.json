{
	"name": "DF_CH_MoveToSLlake_Enriched_STEP6",
	"properties": {
		"folder": {
			"name": "SLIPSCD_Enriched"
		},
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "DS_SLIPLakeIngestion_CSV",
						"type": "DatasetReference"
					},
					"name": "CuratedInput"
				},
				{
					"dataset": {
						"referenceName": "DS_SLIPLakeIngestion_CSV",
						"type": "DatasetReference"
					},
					"name": "ExistingDimensionTable"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "DS_SLIPLakeIngestion_CSV",
						"type": "DatasetReference"
					},
					"name": "DimensionTableSink",
					"description": "Complete the enrich (Gold layer) with SCD details."
				}
			],
			"transformations": [
				{
					"name": "NewAndUpdatedRows"
				},
				{
					"name": "AddHashInput"
				},
				{
					"name": "AddHashExisting"
				},
				{
					"name": "GetMaxSurrogateKey"
				},
				{
					"name": "AddKey"
				},
				{
					"name": "JoinWithMaxSurrogateKey"
				},
				{
					"name": "AddDimensionColumns"
				},
				{
					"name": "FilterForUpdatedValues"
				},
				{
					"name": "UpdateObsolete"
				},
				{
					"name": "DropUnwantedColsInput"
				},
				{
					"name": "UnionAllData"
				},
				{
					"name": "MarkAsUpdate"
				},
				{
					"name": "DropUnwantedColumns"
				},
				{
					"name": "MarkAsInsert"
				},
				{
					"name": "FilterForActive"
				}
			],
			"script": "parameters{\n\tPrimaryKey as string,\n\tColumns as string,\n\tvSinkFile as string\n}\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> CuratedInput\nsource(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ExistingDimensionTable\nAddHashInput, AddHashExisting exists(AddHashInput@id_hash == AddHashExisting@id_hash\n\t&& AddHashInput@columns_hash == AddHashExisting@columns_hash,\n\tnegate:true,\n\tbroadcast: 'auto')~> NewAndUpdatedRows\nCuratedInput derive(id_hash = md5(byName($PrimaryKey)),\n\t\tcolumns_hash = md5(byNames(split($Columns,',')))) ~> AddHashInput\nFilterForActive derive(id_hash = md5(byNames(split($PrimaryKey,','))),\n\t\tcolumns_hash = md5(byNames(split($Columns,',')))) ~> AddHashExisting\nAddHashExisting aggregate(MaxSurrogateKey = iifNull(max(toInteger(byName('SURKEY'))),0)) ~> GetMaxSurrogateKey\nNewAndUpdatedRows keyGenerate(output(SURKEY as long),\n\tstartAt: 1L,\n\tstepValue: 1L) ~> AddKey\nAddKey, GetMaxSurrogateKey join(SURKEY == MaxSurrogateKey || true(),\n\tjoinType:'cross',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> JoinWithMaxSurrogateKey\nJoinWithMaxSurrogateKey derive(SURKEY = SURKEY + iifNull(MaxSurrogateKey,0),\n\t\tSCDACTIVE = 1,\n\t\tSCDACTIVESTARTTIME = currentUTC(),\n\t\tSCDACTIVEENDTIME = toTimestamp(toString(null()))) ~> AddDimensionColumns\nAddHashExisting, NewAndUpdatedRows exists(AddHashExisting@id_hash == AddHashInput@id_hash,\n\tnegate:false,\n\tbroadcast: 'auto')~> FilterForUpdatedValues\nFilterForUpdatedValues derive(SCDACTIVE = 0,\n\t\tSCDACTIVEENDTIME = currentUTC()) ~> UpdateObsolete\nAddDimensionColumns select(mapColumn(\n\t\teach(match(!in(['id_hash','columns_hash','MaxSurrogateKey'],name)))\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DropUnwantedColsInput\nMarkAsInsert, DropUnwantedColumns union(byName: true)~> UnionAllData\nUpdateObsolete alterRow(updateIf(true())) ~> MarkAsUpdate\nMarkAsUpdate select(mapColumn(\n\t\teach(match(!in(['id_hash','columns_hash','MaxSurrogateKey'],name)))\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> DropUnwantedColumns\nDropUnwantedColsInput alterRow(insertIf(true())) ~> MarkAsInsert\nExistingDimensionTable filter(toInteger(byName('SCDACTIVE')) == 1) ~> FilterForActive\nUnionAllData sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1),\n\tformat: 'table') ~> DimensionTableSink"
		}
	}
}